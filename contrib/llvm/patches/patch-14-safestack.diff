diff --git include/llvm/Analysis/TargetTransformInfo.h include/llvm/Analysis/TargetTransformInfo.h
index 4bd5dd8..3d1259f 100644
--- include/llvm/Analysis/TargetTransformInfo.h
+++ include/llvm/Analysis/TargetTransformInfo.h
@@ -438,6 +438,12 @@ public:
   /// any callee-saved registers, so would require a spill and fill.
   virtual unsigned getCostOfKeepingLiveOverCall(ArrayRef<Type*> Tys) const;
 
+  /// \returns True if the target stores the unsafe stack pointer for the safe
+  /// stack instrumentation at a fixed offset in some non-standard address
+  /// space, and populates the address space and offset as appropriate.
+  virtual bool getUnsafeStackPtrLocation(unsigned &AddressSpace,
+                                         unsigned &Offset) const;
+
   /// @}
 
   /// Analysis group identification.
diff --git include/llvm/Bitcode/LLVMBitCodes.h include/llvm/Bitcode/LLVMBitCodes.h
index 043ecd3..56fcca0 100644
--- include/llvm/Bitcode/LLVMBitCodes.h
+++ include/llvm/Bitcode/LLVMBitCodes.h
@@ -376,7 +376,8 @@ namespace bitc {
     ATTR_KIND_IN_ALLOCA = 38,
     ATTR_KIND_NON_NULL = 39,
     ATTR_KIND_JUMP_TABLE = 40,
-    ATTR_KIND_DEREFERENCEABLE = 41
+    ATTR_KIND_DEREFERENCEABLE = 41,
+    ATTR_KIND_SAFESTACK = 42,
   };
 
   enum ComdatSelectionKindCodes {
diff --git include/llvm/IR/Attributes.h include/llvm/IR/Attributes.h
index 5ff48d6..f0ed9d7 100644
--- include/llvm/IR/Attributes.h
+++ include/llvm/IR/Attributes.h
@@ -106,6 +106,7 @@ public:
     StackProtect,          ///< Stack protection.
     StackProtectReq,       ///< Stack protection required.
     StackProtectStrong,    ///< Strong Stack protection.
+    SafeStack,             ///< Safe Stack protection.
     StructRet,             ///< Hidden pointer to structure to return
     SanitizeAddress,       ///< AddressSanitizer is on.
     SanitizeThread,        ///< ThreadSanitizer is on.
diff --git include/llvm/InitializePasses.h include/llvm/InitializePasses.h
index 3028003..8aecb86 100644
--- include/llvm/InitializePasses.h
+++ include/llvm/InitializePasses.h
@@ -237,6 +237,7 @@ void initializeRegionOnlyPrinterPass(PassRegistry&);
 void initializeRegionOnlyViewerPass(PassRegistry&);
 void initializeRegionPrinterPass(PassRegistry&);
 void initializeRegionViewerPass(PassRegistry&);
+void initializeSafeStackPass(PassRegistry&);
 void initializeSCCPPass(PassRegistry&);
 void initializeSROAPass(PassRegistry&);
 void initializeSROA_DTPass(PassRegistry&);
diff --git include/llvm/LinkAllPasses.h include/llvm/LinkAllPasses.h
index 2e8feab..8aeadf6 100644
--- include/llvm/LinkAllPasses.h
+++ include/llvm/LinkAllPasses.h
@@ -126,6 +126,7 @@ namespace {
       (void) llvm::createRegionPrinterPass();
       (void) llvm::createRegionViewerPass();
       (void) llvm::createSCCPPass();
+      (void) llvm::createSafeStackPass();
       (void) llvm::createScalarReplAggregatesPass();
       (void) llvm::createSingleLoopExtractorPass();
       (void) llvm::createStripSymbolsPass();
diff --git include/llvm/Transforms/Instrumentation.h include/llvm/Transforms/Instrumentation.h
index 24e3ef7..6d7c794 100644
--- include/llvm/Transforms/Instrumentation.h
+++ include/llvm/Transforms/Instrumentation.h
@@ -105,6 +105,10 @@ inline ModulePass *createDataFlowSanitizerPassForJIT(StringRef ABIListFile =
 // checking on loads, stores, and other memory intrinsics.
 FunctionPass *createBoundsCheckingPass();
 
+/// createSafeStackPass - This pass splits the stack into a safe stack and
+/// an unsafe stack to protect against stack-based overflow vulnerabilities.
+ModulePass *createSafeStackPass();
+
 } // End llvm namespace
 
 #endif
diff --git lib/Analysis/TargetTransformInfo.cpp lib/Analysis/TargetTransformInfo.cpp
index ef3909b..25d5009 100644
--- lib/Analysis/TargetTransformInfo.cpp
+++ lib/Analysis/TargetTransformInfo.cpp
@@ -247,6 +247,11 @@ unsigned TargetTransformInfo::getCostOfKeepingLiveOverCall(ArrayRef<Type*> Tys)
   return PrevTTI->getCostOfKeepingLiveOverCall(Tys);
 }
 
+bool TargetTransformInfo::getUnsafeStackPtrLocation(unsigned &AddressSpace,
+                                                    unsigned &Offset) const {
+  return PrevTTI->getUnsafeStackPtrLocation(AddressSpace, Offset);
+}
+
 namespace {
 
 struct NoTTI final : ImmutablePass, TargetTransformInfo {
@@ -643,6 +648,10 @@ struct NoTTI final : ImmutablePass, TargetTransformInfo {
     return 0;
   }
 
+  bool getUnsafeStackPtrLocation(unsigned &AddressSpace,
+                                 unsigned &Offset) const override {
+    return false;
+  }
 };
 
 } // end anonymous namespace
diff --git lib/AsmParser/LLLexer.cpp lib/AsmParser/LLLexer.cpp
index de5db1a..e241d61 100644
--- lib/AsmParser/LLLexer.cpp
+++ lib/AsmParser/LLLexer.cpp
@@ -626,6 +626,7 @@ lltok::Kind LLLexer::LexIdentifier() {
   KEYWORD(ssp);
   KEYWORD(sspreq);
   KEYWORD(sspstrong);
+  KEYWORD(safestack);
   KEYWORD(sanitize_address);
   KEYWORD(sanitize_thread);
   KEYWORD(sanitize_memory);
diff --git lib/AsmParser/LLParser.cpp lib/AsmParser/LLParser.cpp
index d209a20..ddd5cd6 100644
--- lib/AsmParser/LLParser.cpp
+++ lib/AsmParser/LLParser.cpp
@@ -967,6 +967,7 @@ bool LLParser::ParseFnAttributeValuePairs(AttrBuilder &B,
     case lltok::kw_ssp:               B.addAttribute(Attribute::StackProtect); break;
     case lltok::kw_sspreq:            B.addAttribute(Attribute::StackProtectReq); break;
     case lltok::kw_sspstrong:         B.addAttribute(Attribute::StackProtectStrong); break;
+    case lltok::kw_safestack:         B.addAttribute(Attribute::SafeStack); break;
     case lltok::kw_sanitize_address:  B.addAttribute(Attribute::SanitizeAddress); break;
     case lltok::kw_sanitize_thread:   B.addAttribute(Attribute::SanitizeThread); break;
     case lltok::kw_sanitize_memory:   B.addAttribute(Attribute::SanitizeMemory); break;
@@ -1268,6 +1269,7 @@ bool LLParser::ParseOptionalParamAttrs(AttrBuilder &B) {
     case lltok::kw_ssp:
     case lltok::kw_sspreq:
     case lltok::kw_sspstrong:
+    case lltok::kw_safestack:
     case lltok::kw_uwtable:
       HaveError |= Error(Lex.getLoc(), "invalid use of function-only attribute");
       break;
@@ -1337,6 +1339,7 @@ bool LLParser::ParseOptionalReturnAttrs(AttrBuilder &B) {
     case lltok::kw_ssp:
     case lltok::kw_sspreq:
     case lltok::kw_sspstrong:
+    case lltok::kw_safestack:
     case lltok::kw_uwtable:
       HaveError |= Error(Lex.getLoc(), "invalid use of function-only attribute");
       break;
diff --git lib/AsmParser/LLToken.h lib/AsmParser/LLToken.h
index 4fb0182..6137bb7 100644
--- lib/AsmParser/LLToken.h
+++ lib/AsmParser/LLToken.h
@@ -134,6 +134,7 @@ namespace lltok {
     kw_ssp,
     kw_sspreq,
     kw_sspstrong,
+    kw_safestack,
     kw_sret,
     kw_sanitize_thread,
     kw_sanitize_memory,
diff --git lib/Bitcode/Reader/BitcodeReader.cpp lib/Bitcode/Reader/BitcodeReader.cpp
index 3d9546f..b930436 100644
--- lib/Bitcode/Reader/BitcodeReader.cpp
+++ lib/Bitcode/Reader/BitcodeReader.cpp
@@ -759,6 +759,8 @@ static Attribute::AttrKind GetAttrFromCode(uint64_t Code) {
     return Attribute::StackProtectReq;
   case bitc::ATTR_KIND_STACK_PROTECT_STRONG:
     return Attribute::StackProtectStrong;
+  case bitc::ATTR_KIND_SAFESTACK:
+    return Attribute::SafeStack;
   case bitc::ATTR_KIND_STRUCT_RET:
     return Attribute::StructRet;
   case bitc::ATTR_KIND_SANITIZE_ADDRESS:
diff --git lib/Bitcode/Writer/BitcodeWriter.cpp lib/Bitcode/Writer/BitcodeWriter.cpp
index a96e866..1204c5a 100644
--- lib/Bitcode/Writer/BitcodeWriter.cpp
+++ lib/Bitcode/Writer/BitcodeWriter.cpp
@@ -226,6 +226,8 @@ static uint64_t getAttrKindEncoding(Attribute::AttrKind Kind) {
     return bitc::ATTR_KIND_STACK_PROTECT_REQ;
   case Attribute::StackProtectStrong:
     return bitc::ATTR_KIND_STACK_PROTECT_STRONG;
+  case Attribute::SafeStack:
+    return bitc::ATTR_KIND_SAFESTACK;
   case Attribute::StructRet:
     return bitc::ATTR_KIND_STRUCT_RET;
   case Attribute::SanitizeAddress:
diff --git lib/CodeGen/Passes.cpp lib/CodeGen/Passes.cpp
index e53e874..35117e8 100644
--- lib/CodeGen/Passes.cpp
+++ lib/CodeGen/Passes.cpp
@@ -26,6 +26,7 @@
 #include "llvm/Support/ErrorHandling.h"
 #include "llvm/Target/TargetLowering.h"
 #include "llvm/Target/TargetSubtargetInfo.h"
+#include "llvm/Transforms/Instrumentation.h"
 #include "llvm/Transforms/Scalar.h"
 #include "llvm/Transforms/Utils/SymbolRewriter.h"
 
@@ -480,6 +481,9 @@ void TargetPassConfig::addISelPrepare() {
   if (!DisableVerify)
     addPass(createDebugInfoVerifierPass());
 
+  // Add both the safe stack and the stack protection passes: each of them will
+  // only protect functions that have corresponding attributes.
+  addPass(createSafeStackPass());
   addPass(createStackProtectorPass(TM));
 
   if (PrintISelInput)
diff --git lib/IR/Attributes.cpp lib/IR/Attributes.cpp
index 04545ea..89bd83b 100644
--- lib/IR/Attributes.cpp
+++ lib/IR/Attributes.cpp
@@ -237,6 +237,8 @@ std::string Attribute::getAsString(bool InAttrGrp) const {
     return "sspreq";
   if (hasAttribute(Attribute::StackProtectStrong))
     return "sspstrong";
+  if (hasAttribute(Attribute::SafeStack))
+    return "safestack";
   if (hasAttribute(Attribute::StructRet))
     return "sret";
   if (hasAttribute(Attribute::SanitizeThread))
@@ -426,6 +428,7 @@ uint64_t AttributeImpl::getAttrMask(Attribute::AttrKind Val) {
   case Attribute::InAlloca:        return 1ULL << 43;
   case Attribute::NonNull:         return 1ULL << 44;
   case Attribute::JumpTable:       return 1ULL << 45;
+  case Attribute::SafeStack:       return 1ULL << 46;
   case Attribute::Dereferenceable:
     llvm_unreachable("dereferenceable attribute not supported in raw format");
   }
diff --git lib/IR/Verifier.cpp lib/IR/Verifier.cpp
index 4bf2d1a..fa929d2 100644
--- lib/IR/Verifier.cpp
+++ lib/IR/Verifier.cpp
@@ -821,6 +821,7 @@ void Verifier::VerifyAttributeTypes(AttributeSet Attrs, unsigned Idx,
         I->getKindAsEnum() == Attribute::StackProtect ||
         I->getKindAsEnum() == Attribute::StackProtectReq ||
         I->getKindAsEnum() == Attribute::StackProtectStrong ||
+        I->getKindAsEnum() == Attribute::SafeStack ||
         I->getKindAsEnum() == Attribute::NoRedZone ||
         I->getKindAsEnum() == Attribute::NoImplicitFloat ||
         I->getKindAsEnum() == Attribute::Naked ||
diff --git lib/Target/CppBackend/CPPBackend.cpp lib/Target/CppBackend/CPPBackend.cpp
index f610fbb..5589f69 100644
--- lib/Target/CppBackend/CPPBackend.cpp
+++ lib/Target/CppBackend/CPPBackend.cpp
@@ -510,6 +510,7 @@ void CppWriter::printAttributes(const AttributeSet &PAL,
       HANDLE_ATTR(StackProtect);
       HANDLE_ATTR(StackProtectReq);
       HANDLE_ATTR(StackProtectStrong);
+      HANDLE_ATTR(SafeStack);
       HANDLE_ATTR(NoCapture);
       HANDLE_ATTR(NoRedZone);
       HANDLE_ATTR(NoImplicitFloat);
diff --git lib/Target/X86/X86TargetTransformInfo.cpp lib/Target/X86/X86TargetTransformInfo.cpp
index 67488f7..e663a19 100644
--- lib/Target/X86/X86TargetTransformInfo.cpp
+++ lib/Target/X86/X86TargetTransformInfo.cpp
@@ -114,6 +114,9 @@ public:
   bool isLegalMaskedLoad (Type *DataType, int Consecutive) const override;
   bool isLegalMaskedStore(Type *DataType, int Consecutive) const override;
 
+  bool getUnsafeStackPtrLocation(unsigned &AddressSpace,
+                                 unsigned &Offset) const override;
+
   /// @}
 };
 
@@ -1174,3 +1177,33 @@ bool X86TTI::isLegalMaskedStore(Type *DataType, int Consecutive) const {
   return isLegalMaskedLoad(DataType, Consecutive);
 }
 
+bool X86TTI::getUnsafeStackPtrLocation(unsigned &AddressSpace,
+                                       unsigned &Offset) const {
+  if (ST->isTargetDarwin() &&
+      TLI->getTargetMachine().getCodeModel() != CodeModel::Kernel) {
+    /* On Darwin, we store the unsafe stack pointer in one of the
+     * thread-specific data slots that are reserved for system libraries.
+     * Such data slots are directly accessible through the %gs segment, and
+     * are described in detail in pthreads/pthread_machdep.h in Darwin Libc.
+     * As of Libc-825, slots 0 - 255 are reserved, but only slots 0 - 119
+     * are actually used. We use slot 192, which is accessible as
+     * %gs:(192 * sizeof(void*))
+     */
+    AddressSpace = 256;
+    Offset = 192 * (ST->is64Bit() ? 8 : 4);
+    return true;
+  }
+
+  /* TODO: To make accessing the unsafe stack pointer faster, we plan to
+   * eventually store it directly in the thread control block data structure on
+   * platforms where this structure is pointed to by %fs or %gs. This is exactly
+   * the same mechanism as currently being used by the traditional stack
+   * protector pass to store the stack guard (see getStackCookieLocation()
+   * function above). Doing so requires changing the tcbhead_t struct in glibc
+   * on Linux and tcb struct in libc on FreeBSD.
+   */
+
+  // By default, the unsafe stack pointer will be stored in a thread-local
+  // variable with a predefined name.
+  return false;
+}
diff --git lib/Transforms/IPO/Inliner.cpp lib/Transforms/IPO/Inliner.cpp
index 6686743..dd266df 100644
--- lib/Transforms/IPO/Inliner.cpp
+++ lib/Transforms/IPO/Inliner.cpp
@@ -93,7 +93,8 @@ static void AdjustCallerSSPLevel(Function *Caller, Function *Callee) {
   // clutter to the IR.
   AttrBuilder B;
   B.addAttribute(Attribute::StackProtect)
-    .addAttribute(Attribute::StackProtectStrong);
+    .addAttribute(Attribute::StackProtectStrong)
+    .addAttribute(Attribute::StackProtectReq);
   AttributeSet OldSSPAttr = AttributeSet::get(Caller->getContext(),
                                               AttributeSet::FunctionIndex,
                                               B);
@@ -101,18 +102,28 @@ static void AdjustCallerSSPLevel(Function *Caller, Function *Callee) {
                CalleeAttr = Callee->getAttributes();
 
   if (CalleeAttr.hasAttribute(AttributeSet::FunctionIndex,
-                              Attribute::StackProtectReq)) {
+                              Attribute::SafeStack)) {
+    Caller->removeAttributes(AttributeSet::FunctionIndex, OldSSPAttr);
+    Caller->addFnAttr(Attribute::SafeStack);
+  } else if (CalleeAttr.hasAttribute(AttributeSet::FunctionIndex,
+                                     Attribute::StackProtectReq) &&
+             !CallerAttr.hasAttribute(AttributeSet::FunctionIndex,
+                                      Attribute::SafeStack)) {
     Caller->removeAttributes(AttributeSet::FunctionIndex, OldSSPAttr);
     Caller->addFnAttr(Attribute::StackProtectReq);
   } else if (CalleeAttr.hasAttribute(AttributeSet::FunctionIndex,
                                      Attribute::StackProtectStrong) &&
              !CallerAttr.hasAttribute(AttributeSet::FunctionIndex,
+                                      Attribute::SafeStack) &&
+             !CallerAttr.hasAttribute(AttributeSet::FunctionIndex,
                                       Attribute::StackProtectReq)) {
     Caller->removeAttributes(AttributeSet::FunctionIndex, OldSSPAttr);
     Caller->addFnAttr(Attribute::StackProtectStrong);
   } else if (CalleeAttr.hasAttribute(AttributeSet::FunctionIndex,
                                      Attribute::StackProtect) &&
            !CallerAttr.hasAttribute(AttributeSet::FunctionIndex,
+                                    Attribute::SafeStack) &&
+           !CallerAttr.hasAttribute(AttributeSet::FunctionIndex,
                                     Attribute::StackProtectReq) &&
            !CallerAttr.hasAttribute(AttributeSet::FunctionIndex,
                                     Attribute::StackProtectStrong))
diff --git lib/Transforms/Instrumentation/Instrumentation.cpp lib/Transforms/Instrumentation/Instrumentation.cpp
index a91fc0e..2750585 100644
--- lib/Transforms/Instrumentation/Instrumentation.cpp
+++ lib/Transforms/Instrumentation/Instrumentation.cpp
@@ -30,6 +30,7 @@ void llvm::initializeInstrumentation(PassRegistry &Registry) {
   initializeThreadSanitizerPass(Registry);
   initializeSanitizerCoverageModulePass(Registry);
   initializeDataFlowSanitizerPass(Registry);
+  initializeSafeStackPass(Registry);
 }
 
 /// LLVMInitializeInstrumentation - C binding for
diff --git lib/Transforms/Instrumentation/SafeStack.cpp lib/Transforms/Instrumentation/SafeStack.cpp
index e97e079..0a2fd5c 100644
--- lib/Transforms/Instrumentation/SafeStack.cpp
+++ lib/Transforms/Instrumentation/SafeStack.cpp
@@ -162,6 +162,7 @@ bool IsSafeStackAlloca(const AllocaInst *AI) {
 /// local variables that are accessed in unsafe ways.
 class SafeStack : public ModulePass {
   const DataLayout *DL;
+
   AliasAnalysis *AA;
 
   Type *StackPtrTy;
@@ -169,8 +170,6 @@ class SafeStack : public ModulePass {
   Type *Int32Ty;
   Type *Int8Ty;
 
-  unsigned NoSafeStackMDKind;
-
   bool runOnFunction(Function &F);
   Constant *getOrCreateUnsafeStackPtr(Function &F);
 
@@ -196,7 +195,6 @@ public:
     IntPtrTy = DL->getIntPtrType(M.getContext());
     Int32Ty = Type::getInt32Ty(M.getContext());
     Int8Ty = Type::getInt8Ty(M.getContext());
-    NoSafeStackMDKind = M.getMDKindID("no_safe_stack");
 
     // Add safe stack instrumentation to all functions that need it
     for (Function &F : M) {
@@ -309,7 +307,7 @@ bool SafeStack::runOnFunction(Function &F) {
     if (AllocaInst *AI = dyn_cast<AllocaInst>(I)) {
       ++NumAllocas;
 
-      if (AI->getMetadata(NoSafeStackMDKind) || IsSafeStackAlloca(AI))
+      if (IsSafeStackAlloca(AI))
         continue;
 
       if (AI->isStaticAlloca()) {
diff --git tools/clang/include/clang/Basic/Attr.td tools/clang/include/clang/Basic/Attr.td
index 3ed7f8d..2e3af8a 100644
--- tools/clang/include/clang/Basic/Attr.td
+++ tools/clang/include/clang/Basic/Attr.td
@@ -1360,6 +1360,13 @@ def X86ForceAlignArgPointer : InheritableAttr, TargetSpecificAttr<TargetX86> {
   let Documentation = [Undocumented];
 }
 
+// Attribute to disable SafeStack (or equivalent) instrumentation.
+def NoSafeStack : InheritableAttr {
+  let Spellings = [GCC<"no_safe_stack">];
+  let Subjects = SubjectList<[Function], ErrorDiag>;
+  let Documentation = [NoSafeStackDocs];
+}
+
 // Attribute to disable AddressSanitizer (or equivalent) checks.
 def NoSanitizeAddress : InheritableAttr {
   let Spellings = [GCC<"no_address_safety_analysis">,
diff --git tools/clang/include/clang/Basic/AttrDocs.td tools/clang/include/clang/Basic/AttrDocs.td
index 530c6e7..770e329 100644
--- tools/clang/include/clang/Basic/AttrDocs.td
+++ tools/clang/include/clang/Basic/AttrDocs.td
@@ -920,6 +920,17 @@ This attribute accepts a single parameter that must be one of the following:
   }];
 }
 
+def NoSafeStackDocs : Documentation {
+  let Category = DocCatFunction;
+  let Content = [{
+Use ``__attribute__((no_safe_stack))`` on a function declaration to specify
+that the safe stack instrumentation should not be applied to that function,
+even if enabled globally (see -fsafe-stack flag). This attribute may be
+required for functions that make assumptions about the exact layout of their
+stack frames.
+  }];
+}
+
 def NoSanitizeAddressDocs : Documentation {
   let Category = DocCatFunction;
   // This function has multiple distinct spellings, and so it requires a custom
diff --git tools/clang/include/clang/Basic/Builtins.def tools/clang/include/clang/Basic/Builtins.def
index 098f5da..488ef00 100644
--- tools/clang/include/clang/Basic/Builtins.def
+++ tools/clang/include/clang/Basic/Builtins.def
@@ -1229,6 +1229,10 @@ BUILTIN(__builtin_addressof, "v*v&", "nct")
 BUILTIN(__builtin_operator_new, "v*z", "c")
 BUILTIN(__builtin_operator_delete, "vv*", "n")
 
+// Safestack builtins
+BUILTIN(__builtin___get_unsafe_stack_start, "v*", "Fn")
+BUILTIN(__builtin___get_unsafe_stack_ptr, "v*", "Fn")
+
 #undef BUILTIN
 #undef LIBBUILTIN
 #undef LANGBUILTIN
diff --git tools/clang/include/clang/Basic/LangOptions.def tools/clang/include/clang/Basic/LangOptions.def
index cf9638d..faddaaa 100644
--- tools/clang/include/clang/Basic/LangOptions.def
+++ tools/clang/include/clang/Basic/LangOptions.def
@@ -193,7 +193,7 @@ ENUM_LANGOPT(ValueVisibilityMode, Visibility, 3, DefaultVisibility,
              "value symbol visibility")
 ENUM_LANGOPT(TypeVisibilityMode, Visibility, 3, DefaultVisibility,
              "type symbol visibility")
-ENUM_LANGOPT(StackProtector, StackProtectorMode, 2, SSPOff,
+ENUM_LANGOPT(StackProtector, StackProtectorMode, 3, SSPOff,
              "stack protector mode")
 ENUM_LANGOPT(SignedOverflowBehavior, SignedOverflowBehaviorTy, 2, SOB_Undefined,
              "signed integer overflow handling")
diff --git tools/clang/include/clang/Basic/LangOptions.h tools/clang/include/clang/Basic/LangOptions.h
index 5ac96c5..4d8e802 100644
--- tools/clang/include/clang/Basic/LangOptions.h
+++ tools/clang/include/clang/Basic/LangOptions.h
@@ -49,7 +49,7 @@ public:
   typedef clang::Visibility Visibility;
   
   enum GCMode { NonGC, GCOnly, HybridGC };
-  enum StackProtectorMode { SSPOff, SSPOn, SSPStrong, SSPReq };
+  enum StackProtectorMode { SSPOff, SSPOn, SSPStrong, SSPReq, SSPSafeStack };
   
   enum SignedOverflowBehaviorTy {
     SOB_Undefined,  // Default C standard behavior.
diff --git tools/clang/include/clang/Driver/Options.td tools/clang/include/clang/Driver/Options.td
index b68a46b..40f8936 100644
--- tools/clang/include/clang/Driver/Options.td
+++ tools/clang/include/clang/Driver/Options.td
@@ -886,6 +886,10 @@ def fstack_protector_strong : Flag<["-"], "fstack-protector-strong">, Group<f_Gr
   HelpText<"Use a strong heuristic to apply stack protectors to functions">;
 def fstack_protector : Flag<["-"], "fstack-protector">, Group<f_Group>,
   HelpText<"Enable stack protectors for functions potentially vulnerable to stack smashing">;
+def fsafe_stack : Flag<["-"], "fsafe-stack">, Group<f_Group>,
+  HelpText<"Enable safe stack protection against stack-based memory corruption errors">;
+def fno_safe_stack : Flag<["-"], "fno-safe-stack">, Group<f_Group>,
+  HelpText<"Disable safe stack protection against stack-based memory corruption errors">;
 def fstandalone_debug : Flag<["-"], "fstandalone-debug">, Group<f_Group>, Flags<[CC1Option]>,
   HelpText<"Emit full debug info for all types used by the program">;
 def fno_standalone_debug : Flag<["-"], "fno-standalone-debug">, Group<f_Group>, Flags<[CC1Option]>,
diff --git tools/clang/lib/CodeGen/CodeGenModule.cpp tools/clang/lib/CodeGen/CodeGenModule.cpp
index 9f4567d..2cfab6b 100644
--- tools/clang/lib/CodeGen/CodeGenModule.cpp
+++ tools/clang/lib/CodeGen/CodeGenModule.cpp
@@ -739,6 +739,9 @@ void CodeGenModule::SetLLVMFunctionAttributesForDefinition(const Decl *D,
     B.addAttribute(llvm::Attribute::StackProtectStrong);
   else if (LangOpts.getStackProtector() == LangOptions::SSPReq)
     B.addAttribute(llvm::Attribute::StackProtectReq);
+  else if (LangOpts.getStackProtector() == LangOptions::SSPSafeStack)
+    if (!D->hasAttr<NoSafeStackAttr>())
+      B.addAttribute(llvm::Attribute::SafeStack);
 
   // Add sanitizer attributes if function is not blacklisted.
   if (!isInSanitizerBlacklist(F, D->getLocation())) {
diff --git tools/clang/lib/Driver/ToolChains.cpp tools/clang/lib/Driver/ToolChains.cpp
index f789fd5..a58a5ad 100644
--- tools/clang/lib/Driver/ToolChains.cpp
+++ tools/clang/lib/Driver/ToolChains.cpp
@@ -10,6 +10,7 @@
 #include "ToolChains.h"
 #include "clang/Basic/ObjCRuntime.h"
 #include "clang/Basic/Version.h"
+#include "clang/Basic/LangOptions.h"
 #include "clang/Config/config.h" // for GCC_INSTALL_PREFIX
 #include "clang/Driver/Compilation.h"
 #include "clang/Driver/Driver.h"
diff --git tools/clang/lib/Driver/Tools.cpp tools/clang/lib/Driver/Tools.cpp
index 5161ddf..4593545 100644
--- tools/clang/lib/Driver/Tools.cpp
+++ tools/clang/lib/Driver/Tools.cpp
@@ -2195,6 +2195,25 @@ static void addSanitizerRuntime(const ToolChain &TC, const ArgList &Args,
     CmdArgs.push_back("-no-whole-archive");
 }
 
+static void addSafeStackRT(
+    const ToolChain &TC, const ArgList &Args, ArgStringList &CmdArgs) {
+  if (!Args.hasFlag(options::OPT_fsafe_stack,
+                    options::OPT_fno_safe_stack, false))
+    return;
+
+  if (Args.hasArg(options::OPT_shared)) {
+    // This is a temporary limitation caused by linking issues.
+    TC.getDriver().Diag(diag::err_drv_argument_not_allowed_with)
+      << "-fsafe-stack" << "-shared";
+  }
+
+  addSanitizerRuntime(TC, Args, CmdArgs, "safestack", false);
+
+  // Safestack runtime requires dl on Linux
+  if (TC.getTriple().isOSLinux())
+    CmdArgs.push_back("-ldl");
+}
+
 // Tries to use a file with the list of dynamic symbols that need to be exported
 // from the runtime library. Returns true if the file was found.
 static bool addSanitizerDynamicList(const ToolChain &TC, const ArgList &Args,
@@ -3689,7 +3708,14 @@ void Clang::ConstructJob(Compilation &C, const JobAction &JA,
 
   // -stack-protector=0 is default.
   unsigned StackProtectorLevel = 0;
-  if (Arg *A = Args.getLastArg(options::OPT_fno_stack_protector,
+  if (Args.hasFlag(options::OPT_fsafe_stack,
+                   options::OPT_fno_safe_stack, false)) {
+    StackProtectorLevel = LangOptions::SSPSafeStack;
+    Args.ClaimAllArgs(options::OPT_fno_stack_protector);
+    Args.ClaimAllArgs(options::OPT_fstack_protector_all);
+    Args.ClaimAllArgs(options::OPT_fstack_protector_strong);
+    Args.ClaimAllArgs(options::OPT_fstack_protector);
+  } else if (Arg *A = Args.getLastArg(options::OPT_fno_stack_protector,
                                options::OPT_fstack_protector_all,
                                options::OPT_fstack_protector_strong,
                                options::OPT_fstack_protector)) {
@@ -5887,6 +5913,21 @@ void darwin::Link::ConstructJob(Compilation &C, const JobAction &JA,
       !Args.hasArg(options::OPT_nostartfiles))
     getMachOToolChain().addStartObjectFileArgs(Args, CmdArgs);
 
+  // SafeStack requires its own runtime libraries
+  // These libraries should be linked first, to make sure the
+  // __safestack_init constructor executes before everything else
+  if (Args.hasFlag(options::OPT_fsafe_stack,
+                   options::OPT_fno_safe_stack, false)) {
+    getMachOToolChain().AddLinkRuntimeLib(Args, CmdArgs,
+                                          "libclang_rt.safestack_osx.a");
+
+    // We need to ensure that the safe stack init function from the safestack
+    // runtime library is linked in, even though it might not be referenced by
+    // any code in the module before LTO optimizations are applied.
+    CmdArgs.push_back("-u");
+    CmdArgs.push_back("___safestack_init");
+  }
+
   Args.AddAllArgs(CmdArgs, options::OPT_L);
 
   LibOpenMP UsedOpenMPLib = LibUnknown;
@@ -6137,6 +6178,8 @@ void solaris::Link::ConstructJob(Compilation &C, const JobAction &JA,
 
   CmdArgs.push_back(Args.MakeArgString("-L" + GCCLibPath));
 
+  addSafeStackRT(getToolChain(), Args, CmdArgs);
+
   Args.AddAllArgs(CmdArgs, options::OPT_L);
   Args.AddAllArgs(CmdArgs, options::OPT_T_Group);
   Args.AddAllArgs(CmdArgs, options::OPT_e);
@@ -6697,6 +6740,8 @@ void freebsd::Link::ConstructJob(Compilation &C, const JobAction &JA,
     CmdArgs.push_back(Args.MakeArgString(ToolChain.GetFilePath(crtbegin)));
   }
 
+  addSafeStackRT(getToolChain(), Args, CmdArgs);
+
   Args.AddAllArgs(CmdArgs, options::OPT_L);
   const ToolChain::path_list &Paths = ToolChain.getFilePaths();
   for (const auto &Path : Paths)
@@ -6993,6 +7038,8 @@ void netbsd::Link::ConstructJob(Compilation &C, const JobAction &JA,
     }
   }
 
+  addSafeStackRT(getToolChain(), Args, CmdArgs);
+
   Args.AddAllArgs(CmdArgs, options::OPT_L);
   Args.AddAllArgs(CmdArgs, options::OPT_T_Group);
   Args.AddAllArgs(CmdArgs, options::OPT_e);
@@ -7536,6 +7583,8 @@ void gnutools::Link::ConstructJob(Compilation &C, const JobAction &JA,
     ToolChain.AddFastMathRuntimeIfAvailable(Args, CmdArgs);
   }
 
+  addSafeStackRT(getToolChain(), Args, CmdArgs);
+
   Args.AddAllArgs(CmdArgs, options::OPT_L);
   Args.AddAllArgs(CmdArgs, options::OPT_u);
 
@@ -7679,6 +7728,8 @@ void minix::Link::ConstructJob(Compilation &C, const JobAction &JA,
       CmdArgs.push_back(Args.MakeArgString(getToolChain().GetFilePath("crtn.o")));
   }
 
+  addSafeStackRT(getToolChain(), Args, CmdArgs);
+
   Args.AddAllArgs(CmdArgs, options::OPT_L);
   Args.AddAllArgs(CmdArgs, options::OPT_T_Group);
   Args.AddAllArgs(CmdArgs, options::OPT_e);
@@ -7805,6 +7856,8 @@ void dragonfly::Link::ConstructJob(Compilation &C, const JobAction &JA,
                               getToolChain().GetFilePath("crtbegin.o")));
   }
 
+  addSafeStackRT(getToolChain(), Args, CmdArgs);
+
   Args.AddAllArgs(CmdArgs, options::OPT_L);
   Args.AddAllArgs(CmdArgs, options::OPT_T_Group);
   Args.AddAllArgs(CmdArgs, options::OPT_e);
diff --git tools/clang/lib/Frontend/CompilerInvocation.cpp tools/clang/lib/Frontend/CompilerInvocation.cpp
index 54025b0..b4f8280 100644
--- tools/clang/lib/Frontend/CompilerInvocation.cpp
+++ tools/clang/lib/Frontend/CompilerInvocation.cpp
@@ -1652,6 +1652,7 @@ static void ParseLangArgs(LangOptions &Opts, ArgList &Args, InputKind IK,
   case 1: Opts.setStackProtector(LangOptions::SSPOn);  break;
   case 2: Opts.setStackProtector(LangOptions::SSPStrong); break;
   case 3: Opts.setStackProtector(LangOptions::SSPReq); break;
+  case 4: Opts.setStackProtector(LangOptions::SSPSafeStack); break;
   }
 
   // Parse -fsanitize= arguments.
diff --git tools/clang/lib/Frontend/InitPreprocessor.cpp tools/clang/lib/Frontend/InitPreprocessor.cpp
index f4241a9..597f738 100644
--- tools/clang/lib/Frontend/InitPreprocessor.cpp
+++ tools/clang/lib/Frontend/InitPreprocessor.cpp
@@ -845,6 +845,8 @@ static void InitializePredefinedMacros(const TargetInfo &TI,
     Builder.defineMacro("__SSP_STRONG__", "2");
   else if (LangOpts.getStackProtector() == LangOptions::SSPReq)
     Builder.defineMacro("__SSP_ALL__", "3");
+  else if (LangOpts.getStackProtector() == LangOptions::SSPSafeStack)
+    Builder.defineMacro("__SAFESTACK__", "4");
 
   if (FEOpts.ProgramAction == frontend::RewriteObjC)
     Builder.defineMacro("__weak", "__attribute__((objc_gc(weak)))");
diff --git tools/clang/lib/Sema/SemaDeclAttr.cpp tools/clang/lib/Sema/SemaDeclAttr.cpp
index d7ce6f1..8e2b101 100644
--- tools/clang/lib/Sema/SemaDeclAttr.cpp
+++ tools/clang/lib/Sema/SemaDeclAttr.cpp
@@ -4689,6 +4689,9 @@ static void ProcessDeclAttribute(Sema &S, Scope *scope, Decl *D,
   case AttributeList::AT_ScopedLockable:
     handleSimpleAttribute<ScopedLockableAttr>(S, D, Attr);
     break;
+  case AttributeList::AT_NoSafeStack:
+    handleSimpleAttribute<NoSafeStackAttr>(S, D, Attr);
+    break;
   case AttributeList::AT_NoSanitizeAddress:
     handleSimpleAttribute<NoSanitizeAddressAttr>(S, D, Attr);
     break;
diff --git lib/Transforms/Instrumentation/SafeStack.cpp lib/Transforms/Instrumentation/SafeStack.cpp
new file mode 100644
index 0000000..e97e079
--- /dev/null
+++ lib/Transforms/Instrumentation/SafeStack.cpp
@@ -0,0 +1,560 @@
+//===-- SafeStack.cpp - Safe Stack Insertion ------------------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This pass splits the stack into the safe stack (kept as-is for LLVM backend)
+// and the unsafe stack (explicitly allocated and managed through the runtime
+// support library).
+//
+//===----------------------------------------------------------------------===//
+
+#define DEBUG_TYPE "safestack"
+#include "llvm/Transforms/Instrumentation.h"
+#include "llvm/ADT/Statistic.h"
+#include "llvm/ADT/Triple.h"
+#include "llvm/Analysis/AliasAnalysis.h"
+#include "llvm/Analysis/TargetTransformInfo.h"
+#include "llvm/IR/Constants.h"
+#include "llvm/IR/DataLayout.h"
+#include "llvm/IR/DerivedTypes.h"
+#include "llvm/IR/DIBuilder.h"
+#include "llvm/IR/Function.h"
+#include "llvm/IR/InstIterator.h"
+#include "llvm/IR/Instructions.h"
+#include "llvm/IR/IntrinsicInst.h"
+#include "llvm/IR/Intrinsics.h"
+#include "llvm/IR/IRBuilder.h"
+#include "llvm/IR/Module.h"
+#include "llvm/Pass.h"
+#include "llvm/Support/CommandLine.h"
+#include "llvm/Support/Debug.h"
+#include "llvm/Support/Format.h"
+#include "llvm/Support/raw_os_ostream.h"
+#include "llvm/Transforms/Utils/Local.h"
+#include "llvm/Transforms/Utils/ModuleUtils.h"
+
+using namespace llvm;
+
+namespace llvm {
+
+STATISTIC(NumFunctions, "Total number of functions");
+STATISTIC(NumUnsafeStackFunctions, "Number of functions with unsafe stack");
+STATISTIC(NumUnsafeStackRestorePointsFunctions,
+          "Number of functions that use setjmp or exceptions");
+
+STATISTIC(NumAllocas, "Total number of allocas");
+STATISTIC(NumUnsafeStaticAllocas, "Number of unsafe static allocas");
+STATISTIC(NumUnsafeDynamicAllocas, "Number of unsafe dynamic allocas");
+STATISTIC(NumUnsafeStackRestorePoints, "Number of setjmps and landingpads");
+
+} // namespace llvm
+
+namespace {
+
+/// Check whether a given alloca instructino (AI) should be put on the safe
+/// stack or not. The function analyzes all uses of AI and checks whether it is
+/// only accessed in a memory safe way (as decided statically).
+bool IsSafeStackAlloca(const AllocaInst *AI) {
+  // Go through all uses of this alloca and check whether all accesses to the
+  // allocated object are statically known to be memory safe and, hence, the
+  // object can be placed on the safe stack.
+
+  SmallPtrSet<const Value*, 16> Visited;
+  SmallVector<const Instruction*, 8> WorkList;
+  WorkList.push_back(AI);
+
+  // A DFS search through all uses of the alloca in bitcasts/PHI/GEPs/etc.
+  while (!WorkList.empty()) {
+    const Instruction *V = WorkList.pop_back_val();
+    for (const Use &UI : V->uses()) {
+      const Instruction *I = cast<const Instruction>(UI.getUser());
+      assert(V == UI.get());
+
+      switch (I->getOpcode()) {
+      case Instruction::Load:
+        // Loading from a pointer is safe
+        break;
+      case Instruction::VAArg:
+        // "va-arg" from a pointer is safe
+        break;
+      case Instruction::Store:
+        if (V == I->getOperand(0))
+          // Stored the pointer - conservatively assume it may be unsafe
+          return false;
+        // Storing to the pointee is safe
+        break;
+
+      case Instruction::GetElementPtr:
+        if (!cast<const GetElementPtrInst>(I)->hasAllConstantIndices())
+          // GEP with non-constant indices can lead to memory errors
+          return false;
+
+        // We assume that GEP on static alloca with constant indices is safe,
+        // otherwise a compiler would detect it and warn during compilation.
+
+        if (!isa<const ConstantInt>(AI->getArraySize()))
+          // However, if the array size itself is not constant, the access
+          // might still be unsafe at runtime.
+          return false;
+
+        /* fallthough */
+
+      case Instruction::BitCast:
+      case Instruction::IntToPtr:
+      case Instruction::PHI:
+      case Instruction::PtrToInt:
+      case Instruction::Select:
+        // The object can be safe or not, depending on how the result of the
+        // BitCast/PHI/Select/GEP/etc. is used.
+        if (Visited.insert(I).second)
+          WorkList.push_back(cast<const Instruction>(I));
+        break;
+
+      case Instruction::Call:
+      case Instruction::Invoke: {
+        ImmutableCallSite CS(I);
+
+        // Given we don't care about information leak attacks at this point,
+        // the object is considered safe if a pointer to it is passed to a
+        // function that only reads memory nor returns any value. This function
+        // can neither do unsafe writes itself nor capture the pointer (or
+        // return it) to do unsafe writes to it elsewhere. The function also
+        // shouldn't unwind (a readonly function can leak bits by throwing an
+        // exception or not depending on the input value).
+        if (CS.onlyReadsMemory() /* && CS.doesNotThrow()*/ &&
+            I->getType()->isVoidTy())
+          continue;
+
+        // LLVM 'nocapture' attribute is only set for arguments whose address
+        // is not stored, passed around, or used in any other non-trivial way.
+        // We assume that passing a pointer to an object as a 'nocapture'
+        // argument is safe.
+        // FIXME: a more precise solution would require an interprocedural
+        // analysis here, which would look at all uses of an argument inside
+        // the function being called.
+        ImmutableCallSite::arg_iterator B = CS.arg_begin(), E = CS.arg_end();
+        for (ImmutableCallSite::arg_iterator A = B; A != E; ++A)
+          if (A->get() == V && !CS.doesNotCapture(A - B))
+            // The parameter is not marked 'nocapture' - unsafe
+            return false;
+        continue;
+      }
+
+      default:
+        // The object is unsafe if it is used in any other way.
+        return false;
+      }
+    }
+  }
+
+  // All uses of the alloca are safe, we can place it on the safe stack.
+  return true;
+}
+
+/// The SafeStack pass splits the stack of each function into the
+/// safe stack, which is only accessed through memory safe dereferences
+/// (as determined statically), and the unsafe stack, which contains all
+/// local variables that are accessed in unsafe ways.
+class SafeStack : public ModulePass {
+  const DataLayout *DL;
+  AliasAnalysis *AA;
+
+  Type *StackPtrTy;
+  Type *IntPtrTy;
+  Type *Int32Ty;
+  Type *Int8Ty;
+
+  unsigned NoSafeStackMDKind;
+
+  bool runOnFunction(Function &F);
+  Constant *getOrCreateUnsafeStackPtr(Function &F);
+
+public:
+  static char ID; // Pass identification, replacement for typeid.
+  SafeStack(): ModulePass(ID), DL(nullptr) {
+    initializeSafeStackPass(*PassRegistry::getPassRegistry());
+  }
+
+  virtual void getAnalysisUsage(AnalysisUsage &AU) const {
+    AU.addRequired<AliasAnalysis>();
+    AU.addRequired<TargetTransformInfo>();
+  }
+
+  virtual bool runOnModule(Module &M) {
+    DEBUG(dbgs() << "[SafeStack] Module: "
+                 << M.getModuleIdentifier() << "\n");
+
+    AA = &getAnalysis<AliasAnalysis>();
+    DL = M.getDataLayout();
+
+    StackPtrTy = Type::getInt8PtrTy(M.getContext());
+    IntPtrTy = DL->getIntPtrType(M.getContext());
+    Int32Ty = Type::getInt32Ty(M.getContext());
+    Int8Ty = Type::getInt8Ty(M.getContext());
+    NoSafeStackMDKind = M.getMDKindID("no_safe_stack");
+
+    // Add safe stack instrumentation to all functions that need it
+    for (Function &F : M) {
+      DEBUG(dbgs() << "[SafeStack] Function: " << F.getName() << "\n");
+
+      if (!F.hasFnAttribute(Attribute::SafeStack)) {
+        DEBUG(dbgs() << "[SafeStack]     safestack is not requested"
+                        " for this function\n");
+        continue;
+      }
+
+      if (F.isDeclaration()) {
+        DEBUG(dbgs() << "[SafeStack]     function definition"
+                        " is not available\n");
+        continue;
+      }
+
+      {
+        // Make sure the regular stack protector won't run on this function
+        // (safestack attribute takes precedence)
+        AttrBuilder B;
+        B.addAttribute(Attribute::StackProtect)
+            .addAttribute(Attribute::StackProtectReq)
+            .addAttribute(Attribute::StackProtectStrong);
+        F.removeAttributes(AttributeSet::FunctionIndex, AttributeSet::get(
+              F.getContext(), AttributeSet::FunctionIndex, B));
+      }
+
+      if (AA->onlyReadsMemory(&F)) {
+        // XXX: we don't protect against information leak attacks for now
+        DEBUG(dbgs() << "[SafeStack]     function only reads memory\n");
+        continue;
+      }
+
+      runOnFunction(F);
+      DEBUG(dbgs() << "[SafeStack]     safestack applied\n");
+    }
+
+    return true;
+  }
+}; // class SafeStack
+
+Constant *SafeStack::getOrCreateUnsafeStackPtr(Function &F) {
+  const TargetTransformInfo *TTI = &getAnalysis<TargetTransformInfo>();
+
+  // Check where the unsafe stack pointer is stored on this architecture
+  unsigned AddressSpace, Offset;
+  if (TTI->getUnsafeStackPtrLocation(AddressSpace, Offset)) {
+    // The unsafe stack pointer is stored at a fixed location
+    // (usually in the thread control block)
+    Constant *OffsetVal = ConstantInt::get(Int32Ty, Offset);
+    return ConstantExpr::getIntToPtr(
+        OffsetVal, Int8Ty->getPointerTo()->getPointerTo(AddressSpace));
+  } else {
+    // The unsafe stack pointer is stored in a global variable with a magic name
+    // FIXME: share this constant between LLVM and compiler-rt
+    // FIXME: make the name start with "llvm."
+    static const char* unsafe_stack_ptr_var = "__safestack_unsafe_stack_ptr";
+
+    auto UnsafeStackPtr = dyn_cast_or_null<GlobalVariable>(
+          F.getParent()->getNamedValue(unsafe_stack_ptr_var));
+
+    if (!UnsafeStackPtr) {
+      // The global variable is not defined yet, define it ourselves
+      UnsafeStackPtr = new GlobalVariable(
+          /*Module=*/*F.getParent(), /*Type=*/Int8Ty->getPointerTo(),
+          /*isConstant=*/false, /*Linkage=*/GlobalValue::ExternalLinkage,
+          /*Initializer=*/0, /*Name=*/unsafe_stack_ptr_var,
+          /*InsertBefore=*/nullptr,
+          /*ThreadLocalMode=*/GlobalValue::InitialExecTLSModel);
+    } else {
+      // The variable exists, check its type and attributes
+      if (UnsafeStackPtr->getType() != Int8Ty->getPointerTo()) {
+        report_fatal_error(Twine(unsafe_stack_ptr_var) +
+                           " must have void* type");
+      }
+
+      if (!UnsafeStackPtr->isThreadLocal()) {
+        report_fatal_error(Twine(unsafe_stack_ptr_var) +
+                           " must be thread-local");
+      }
+    }
+
+    return UnsafeStackPtr;
+  }
+}
+
+bool SafeStack::runOnFunction(Function &F) {
+  ++NumFunctions;
+
+  unsigned StackAlignment = 16;
+  Constant *UnsafeStackPtr = getOrCreateUnsafeStackPtr(F);
+
+  SmallVector<AllocaInst*, 16> StaticAllocas;
+  SmallVector<AllocaInst*, 4> DynamicAllocas;
+  SmallVector<ReturnInst*, 4> Returns;
+
+  // Collect all points where stack gets unwound and needs to be restored
+  // This is only necessary because the runtime (setjmp and unwind code) is
+  // not aware of the unsafe stack and won't unwind/restore it prorerly.
+  // To work around this problem without changing the runtime, we insert
+  // instrumentation to restore the unsafe stack pointer when necessary.
+  SmallVector<Instruction*, 4> StackRestorePoints;
+
+  // Find all static and dynamic alloca instructions that must be moved to the
+  // unsafe stack, all return instructions and stack restore points
+  for (inst_iterator It = inst_begin(&F), Ie = inst_end(&F); It != Ie; ++It) {
+    Instruction *I = &*It;
+
+    if (AllocaInst *AI = dyn_cast<AllocaInst>(I)) {
+      ++NumAllocas;
+
+      if (AI->getMetadata(NoSafeStackMDKind) || IsSafeStackAlloca(AI))
+        continue;
+
+      if (AI->isStaticAlloca()) {
+        ++NumUnsafeStaticAllocas;
+        StaticAllocas.push_back(AI);
+      } else {
+        ++NumUnsafeDynamicAllocas;
+        DynamicAllocas.push_back(AI);
+      }
+
+    } else if (ReturnInst *RI = dyn_cast<ReturnInst>(I)) {
+      Returns.push_back(RI);
+
+    } else if (CallInst *CI = dyn_cast<CallInst>(I)) {
+      // setjmps require stack restore
+      if (CI->getCalledFunction() && CI->canReturnTwice())
+          //CI->getCalledFunction()->getName() == "_setjmp")
+        StackRestorePoints.push_back(CI);
+
+    } else if (LandingPadInst *LP = dyn_cast<LandingPadInst>(I)) {
+      // Excpetion landing pads require stack restore
+      StackRestorePoints.push_back(LP);
+    }
+  }
+
+  if (StaticAllocas.empty() && DynamicAllocas.empty() &&
+      StackRestorePoints.empty())
+    return false; // Nothing to do in this function
+
+  if (!StaticAllocas.empty() || !DynamicAllocas.empty())
+    ++NumUnsafeStackFunctions; // This function has the unsafe stack
+
+  if (!StackRestorePoints.empty())
+    ++NumUnsafeStackRestorePointsFunctions;
+
+  DIBuilder DIB(*F.getParent());
+  IRBuilder<> IRB(F.getEntryBlock().getFirstInsertionPt());
+
+  // The top of the unsafe stack after all unsafe static allocas are allocated
+  Value *StaticTop = NULL;
+
+  if (!StaticAllocas.empty()) {
+    // We explicitly compute and set the unsafe stack layout for all unsafe
+    // static alloca instructions. We save the unsafe "base pointer" in the
+    // prologue into a local variable and restore it in the epilogue.
+
+    // Load the current stack pointer (we'll also use it as a base pointer)
+    // FIXME: use a dedicated register for it ?
+    Instruction *BasePointer = IRB.CreateLoad(UnsafeStackPtr, false,
+                                              "unsafe_stack_ptr");
+    assert(BasePointer->getType() == StackPtrTy);
+
+    for (ReturnInst *RI : Returns) {
+      IRB.SetInsertPoint(RI);
+      IRB.CreateStore(BasePointer, UnsafeStackPtr);
+    }
+
+    // Compute maximum alignment among static objects on the unsafe stack
+    unsigned MaxAlignment = 0;
+    for (AllocaInst *AI : StaticAllocas) {
+      Type *Ty = AI->getAllocatedType();
+      unsigned Align =
+        std::max((unsigned)DL->getPrefTypeAlignment(Ty), AI->getAlignment());
+      if (Align > MaxAlignment)
+        MaxAlignment = Align;
+    }
+
+    if (MaxAlignment > StackAlignment) {
+      // Re-align the base pointer according to the max requested alignment
+      assert(isPowerOf2_32(MaxAlignment));
+      IRB.SetInsertPoint(cast<Instruction>(BasePointer->getNextNode()));
+      BasePointer = cast<Instruction>(IRB.CreateIntToPtr(
+          IRB.CreateAnd(IRB.CreatePtrToInt(BasePointer, IntPtrTy),
+                        ConstantInt::get(IntPtrTy, ~uint64_t(MaxAlignment-1))),
+          StackPtrTy));
+    }
+
+    // Allocate space for every unsafe static AllocaInst on the unsafe stack
+    int64_t StaticOffset = 0; // Current stack top
+    for (AllocaInst *AI : StaticAllocas) {
+      IRB.SetInsertPoint(AI);
+
+      ConstantInt *CArraySize = cast<ConstantInt>(AI->getArraySize());
+      Type *Ty = AI->getAllocatedType();
+
+      uint64_t Size = DL->getTypeAllocSize(Ty) * CArraySize->getZExtValue();
+      if (Size == 0) Size = 1; // Don't create zero-sized stack objects.
+
+      // Ensure the object is properly aligned
+      unsigned Align =
+        std::max((unsigned)DL->getPrefTypeAlignment(Ty), AI->getAlignment());
+
+      // Add alignment
+      // NOTE: we ensure that BasePointer itself is aligned to >= Align
+      StaticOffset += Size;
+      StaticOffset = (StaticOffset + Align - 1) / Align * Align;
+
+      Value *Off = IRB.CreateGEP(BasePointer, // BasePointer is i8*
+                      ConstantInt::get(Int32Ty, -StaticOffset));
+      Value *NewAI = IRB.CreateBitCast(Off, AI->getType(), AI->getName());
+      if (AI->hasName() && isa<Instruction>(NewAI))
+        cast<Instruction>(NewAI)->takeName(AI);
+
+      // Replace alloc with the new location
+      replaceDbgDeclareForAlloca(AI, NewAI, DIB);
+      AI->replaceAllUsesWith(NewAI);
+      AI->eraseFromParent();
+    }
+
+    // Re-align BasePointer so that our callees would see it aligned as expected
+    // FIXME: no need to update BasePointer in leaf functions
+    StaticOffset = (StaticOffset + StackAlignment - 1)
+                    / StackAlignment * StackAlignment;
+
+    // Update shadow stack pointer in the function epilogue
+    IRB.SetInsertPoint(cast<Instruction>(BasePointer->getNextNode()));
+
+    StaticTop = IRB.CreateGEP(BasePointer,
+           ConstantInt::get(Int32Ty, -StaticOffset), "unsafe_stack_static_top");
+    IRB.CreateStore(StaticTop, UnsafeStackPtr);
+  }
+
+  IRB.SetInsertPoint(
+          StaticTop ? cast<Instruction>(StaticTop)->getNextNode()
+                    : (Instruction*) F.getEntryBlock().getFirstInsertionPt());
+
+  // Safe stack object that stores the current unsafe stack top. It is updated
+  // as unsafe dynamic (non-constant-sized) allocas are allocated and freed.
+  // This is only needed if we need to restore stack pointer after longjmp
+  // or exceptions.
+  // FIXME: a better alternative might be to store the unsafe stack pointer
+  // before setjmp / invoke instructions.
+  AllocaInst *DynamicTop = NULL;
+
+  if (!StackRestorePoints.empty()) {
+    // We need the current value of the shadow stack pointer to restore
+    // after longjmp or exception catching.
+
+    // FIXME: in the future, this should be handled by the longjmp/exception
+    // runtime itself
+
+    if (!DynamicAllocas.empty()) {
+      // If we also have dynamic alloca's, the stack pointer value changes
+      // throughout the function. For now we store it in an allca.
+      DynamicTop = IRB.CreateAlloca(StackPtrTy, 0, "unsafe_stack_dynamic_ptr");
+    }
+
+    if (!StaticTop) {
+      // We need to original unsafe stack pointer value, even if there are
+      // no unsafe static allocas
+      StaticTop = IRB.CreateLoad(UnsafeStackPtr, false, "unsafe_stack_ptr");
+    }
+
+    if (!DynamicAllocas.empty()) {
+      IRB.CreateStore(StaticTop, DynamicTop);
+    }
+  }
+
+  // Handle dynamic alloca now
+  for (AllocaInst *AI : DynamicAllocas) {
+    IRB.SetInsertPoint(AI);
+
+    // Compute the new SP value (after AI)
+    Value *ArraySize = AI->getArraySize();
+    if (ArraySize->getType() != IntPtrTy)
+      ArraySize = IRB.CreateIntCast(ArraySize, IntPtrTy, false);
+
+    Type *Ty = AI->getAllocatedType();
+    uint64_t TySize = DL->getTypeAllocSize(Ty);
+    Value *Size = IRB.CreateMul(ArraySize, ConstantInt::get(IntPtrTy, TySize));
+
+    Value *SP = IRB.CreatePtrToInt(IRB.CreateLoad(UnsafeStackPtr), IntPtrTy);
+    SP = IRB.CreateSub(SP, Size);
+
+    // Align the SP value to satisfy the AllocaInst, type and stack alignments
+    unsigned Align = std::max(
+      std::max((unsigned)DL->getPrefTypeAlignment(Ty), AI->getAlignment()),
+      (unsigned) StackAlignment);
+
+    assert(isPowerOf2_32(Align));
+    Value *NewTop = IRB.CreateIntToPtr(
+        IRB.CreateAnd(SP, ConstantInt::get(IntPtrTy, ~uint64_t(Align-1))),
+        StackPtrTy);
+
+    // Save the stack pointer
+    IRB.CreateStore(NewTop, UnsafeStackPtr);
+    if (DynamicTop) {
+      IRB.CreateStore(NewTop, DynamicTop);
+    }
+
+    Value *NewAI = IRB.CreateIntToPtr(SP, AI->getType());
+    if (AI->hasName() && isa<Instruction>(NewAI))
+      NewAI->takeName(AI);
+
+    replaceDbgDeclareForAlloca(AI, NewAI, DIB);
+    AI->replaceAllUsesWith(NewAI);
+    AI->eraseFromParent();
+  }
+
+  if (!DynamicAllocas.empty()) {
+    // Now go through the instructions again, replacing stacksave/stackrestore
+    for (inst_iterator It = inst_begin(&F), Ie = inst_end(&F); It != Ie;) {
+      Instruction *I = &*(It++);
+      IntrinsicInst *II = dyn_cast<IntrinsicInst>(I);
+      if (!II)
+        continue;
+
+      if (II->getIntrinsicID() == Intrinsic::stacksave) {
+        IRB.SetInsertPoint(II);
+        Instruction *LI = IRB.CreateLoad(UnsafeStackPtr);
+        LI->takeName(II);
+        II->replaceAllUsesWith(LI);
+        II->eraseFromParent();
+      } else if (II->getIntrinsicID() == Intrinsic::stackrestore) {
+        IRB.SetInsertPoint(II);
+        Instruction *SI = IRB.CreateStore(II->getArgOperand(0), UnsafeStackPtr);
+        SI->takeName(II);
+        assert(II->use_empty());
+        II->eraseFromParent();
+      }
+    }
+  }
+
+  // Restore current stack pointer after longjmp/exception catch
+  for (Instruction *I : StackRestorePoints) {
+    ++NumUnsafeStackRestorePoints;
+
+    IRB.SetInsertPoint(cast<Instruction>(I->getNextNode()));
+    Value *CurrentTop = DynamicTop ? IRB.CreateLoad(DynamicTop) : StaticTop;
+    IRB.CreateStore(CurrentTop, UnsafeStackPtr);
+  }
+
+  return true;
+}
+
+} // end anonymous namespace
+
+char SafeStack::ID = 0;
+INITIALIZE_PASS_BEGIN(SafeStack, "safe-stack",
+                      "Safe Stack instrumentation pass", false, false)
+INITIALIZE_AG_DEPENDENCY(TargetTransformInfo)
+INITIALIZE_PASS_END(SafeStack, "safe-stack",
+                    "Safe Stack instrumentation pass", false, false)
+
+
+ModulePass *llvm::createSafeStackPass() {
+  return new SafeStack();
+}
